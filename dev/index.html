<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MixedSubdivisions ¬∑ MixedSubdivisions.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MixedSubdivisions.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>MixedSubdivisions</a><ul class="internal"><li><a class="toctext" href="#Installation-1">Installation</a></li><li><a class="toctext" href="#Short-introduction-1">Short introduction</a></li><li><a class="toctext" href="#API-1">API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>MixedSubdivisions</a></li></ul><a class="edit-page" href="https://github.com/saschatimme/MixedSubdivisions.jl/blob/master/docs/src/index.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>MixedSubdivisions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h1><p><a href="https://github.com/saschatimme/MixedSubdivisions.jl">MixedSubdivisions.jl</a> is package for computing a (fine) mixed subdivision and the <a href="https://en.wikipedia.org/wiki/Mixed_volume">mixed volume</a> of lattice polytopes. The mixed volume of lattice polytopes arising as Newton polytopes of a polynomial system gives an upper bound of the number of solutions of the system. This is the celebrated <a href="https://en.wikipedia.org/wiki/Bernstein‚ÄìKushnirenko_theorem">BKK-Theorem</a>. A (fine) mixed subdivision can be used to efficiently solve sparse polynomial systems as first described in <a href="https://www.jstor.org/stable/2153370">A Polyhedral Method for Solving Sparse Polynomial Systems</a> by Huber and Sturmfels.</p><p>There are many algorithms for computing mixed volumes and mixed subdivisions. This implementation is based on the tropical homotopy continuation algorithm by Anders Jensen described in <a href="https://arxiv.org/abs/1601.02818">arXiv:1601.02818</a>.</p><h2><a class="nav-anchor" id="Installation-1" href="#Installation-1">Installation</a></h2><p>The package can be installed via the Julia package manager</p><pre><code class="language-julia">pkg&gt; add MixedSubdivisions</code></pre><h2><a class="nav-anchor" id="Short-introduction-1" href="#Short-introduction-1">Short introduction</a></h2><p>We support polynomial input through the <a href="https://github.com/JuliaAlgebra/DynamicPolynomials.jl">DynamicPolynomials</a> package.</p><pre><code class="language-julia">@polyvar x y;
# create two polynomials
f = y^2 + x * y + x + 1;
g = x^2 + x * y + y + 1;

# mixed volume
mixed_volume([f, g])</code></pre><pre><code class="language-none">4</code></pre><p>Alternatively we could also give directly the supports to <code>mixed_volume</code>.</p><pre><code class="language-julia">A = support([f, g])</code></pre><pre><code class="language-none">2-element Array{Array{Int32,2},1}:
 [1 0 1 0; 1 2 0 0]
 [2 1 0 0; 0 1 1 0]</code></pre><pre><code class="language-julia">mixed_volume(A)</code></pre><pre><code class="language-none">4</code></pre><p>Now let&#39;s compute the mixed cells with respect to a given lift.</p><pre><code class="language-julia">w‚ÇÅ = [2, 0, 0, 0];
w‚ÇÇ = [8, 4, 3, 0];
mixed_cells(A, [w‚ÇÅ, w‚ÇÇ])</code></pre><pre><code class="language-none">2-element Array{MixedCell,1}:
 MixedCell:
 ‚Ä¢ volume ‚Üí 3
 ‚Ä¢ indices ‚Üí Tuple{Int64,Int64}[(2, 3), (4, 2)]
 ‚Ä¢ normal ‚Üí [-2.66667, -1.33333]
 MixedCell:
 ‚Ä¢ volume ‚Üí 1
 ‚Ä¢ indices ‚Üí Tuple{Int64,Int64}[(3, 1), (1, 2)]
 ‚Ä¢ normal ‚Üí [-6.0, -2.0]</code></pre><p>Now let&#39;s compare that to another lift.</p><pre><code class="language-julia">v‚ÇÅ = [1, 0, 0, 0];
v‚ÇÇ = [8, 4, 3, 0];
mixed_cells(A, [v‚ÇÅ, v‚ÇÇ])</code></pre><pre><code class="language-none">3-element Array{MixedCell,1}:
 MixedCell:
 ‚Ä¢ volume ‚Üí 2
 ‚Ä¢ indices ‚Üí Tuple{Int64,Int64}[(2, 1), (4, 2)]
 ‚Ä¢ normal ‚Üí [-2.5, -1.5]
 MixedCell:
 ‚Ä¢ volume ‚Üí 1
 ‚Ä¢ indices ‚Üí Tuple{Int64,Int64}[(3, 1), (2, 4)]
 ‚Ä¢ normal ‚Üí [-3.0, -1.0]
 MixedCell:
 ‚Ä¢ volume ‚Üí 1
 ‚Ä¢ indices ‚Üí Tuple{Int64,Int64}[(3, 1), (1, 2)]
 ‚Ä¢ normal ‚Üí [-5.0, -1.0]</code></pre><p>If you don&#39;t want to wait until all mixed cells got computed you can also use the <code>MixedCellIterator</code></p><pre><code class="language-none">for cell in MixedCellIterator(A, [v‚ÇÅ, v‚ÇÇ])
    println(cell)
end</code></pre><pre><code class="language-none">MixedCell:
 ‚Ä¢ volume ‚Üí 2
 ‚Ä¢ indices ‚Üí Tuple{Int64,Int64}[(2, 1), (4, 2)]
 ‚Ä¢ normal ‚Üí [-2.5, -1.5]
MixedCell:
 ‚Ä¢ volume ‚Üí 1
 ‚Ä¢ indices ‚Üí Tuple{Int64,Int64}[(3, 1), (2, 4)]
 ‚Ä¢ normal ‚Üí [-3.0, -1.0]
MixedCell:
 ‚Ä¢ volume ‚Üí 1
 ‚Ä¢ indices ‚Üí Tuple{Int64,Int64}[(3, 1), (1, 2)]
 ‚Ä¢ normal ‚Üí [-5.0, -1.0]</code></pre><h2><a class="nav-anchor" id="API-1" href="#API-1">API</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MixedSubdivisions.mixed_volume" href="#MixedSubdivisions.mixed_volume"><code>MixedSubdivisions.mixed_volume</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mixed_volume(F::Vector{&lt;:MP.AbstractPolynomialLike}; report_progress=true, algorithm=:regeneration)
mixed_volume(ùë®::Vector{&lt;:Matrix}; report_progress=true, algorithm=:regeneration)</code></pre><p>Compute the mixed volume of the given polynomial system <code>F</code> resp. represented by the support <code>ùë®</code>. There are two possible values for <code>algorithm</code>:</p><ul><li><code>:total_degree</code>: Use the total degree homotopy algorithm described in Section 7.1</li><li><code>:regeneration</code>: Use the tropical regeneration algorithm described in Section 7.2</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MixedSubdivisions.MixedCell" href="#MixedSubdivisions.MixedCell"><code>MixedSubdivisions.MixedCell</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MixedCell</code></pre><p>Data structure representing a (fine) mixed cell.</p><p><strong>Fields</strong></p><ul><li><code>indices::Vector{NTuple{2, Int}}</code>: The columns of the support creating the mixed cell.</li><li><code>normal::Vector{Float64}</code>: The inner normal vector of the lifted mixed cell.</li><li><code>volume::Int</code>: The volume of the mixed cell.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MixedSubdivisions.volume" href="#MixedSubdivisions.volume"><code>MixedSubdivisions.volume</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">volume(C::MixedCell)</code></pre><p>Returns the volume of the mixed cell <code>C</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MixedSubdivisions.normal" href="#MixedSubdivisions.normal"><code>MixedSubdivisions.normal</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">normal(C::MixedCell)</code></pre><p>The inner normal vector of the lifted mixed cell.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MixedSubdivisions.indices" href="#MixedSubdivisions.indices"><code>MixedSubdivisions.indices</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">indices(C::MixedCell)</code></pre><p>Returns the indices of the support creating the mixed cell.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MixedSubdivisions.MixedCellIterator" href="#MixedSubdivisions.MixedCellIterator"><code>MixedSubdivisions.MixedCellIterator</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MixedCellIterator(support:Vector{&lt;:Matrix}, lifting::Vector{&lt;:Vector{&lt;:Integer}})</code></pre><p>Returns an iterator over all (fine) mixed cells of the given <code>support</code> induced by the given <code>lifting</code>. If the lifting is not sufficiently generic the mixed cells induced by a sligtly perturbated lifting are computed. The iterator returns in each iteration a <a href="#MixedSubdivisions.MixedCell"><code>MixedCell</code></a>. Note that due to efficiency reason the same object is returned in each iteration, i.e., if you want to store the computed cells you need to make a <code>copy</code>. Alternatively you can also use <a href="#MixedSubdivisions.mixed_cells"><code>mixed_cells</code></a> to compute all mixed cells.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MixedSubdivisions.mixed_cells" href="#MixedSubdivisions.mixed_cells"><code>MixedSubdivisions.mixed_cells</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mixed_cells(support::Vector{&lt;:Matrix}, lifting::Vector{&lt;:Vector})</code></pre><p>Compute all (fine) mixed cells of the given <code>support</code> induced by the given <code>lifting</code>. If the lifting is not sufficiently generic the mixed cells induced by a sligtly perturbated lifting are computed. The mixed cells are stored as a <a href="#MixedSubdivisions.MixedCell"><code>MixedCell</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MixedSubdivisions.support" href="#MixedSubdivisions.support"><code>MixedSubdivisions.support</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">support(F::Vector{&lt;:MP.AbstractPolynomialLike}, vars=MP.variables(F), T::Type{&lt;:Integer}=Int32)</code></pre><p>Compute the support of the polynomial system <code>F</code> with the given variables <code>vars</code>. The returned matrices have element type <code>T</code>.</p></div></div></section><footer><hr/></footer></article></body></html>
